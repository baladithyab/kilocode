/**
 * SkillSynthesizer - Template-based skill generation for Darwin
 *
 * Responsibilities:
 * - Generate skills from templates
 * - Generate skills from doom_loop learning signals
 * - Create TypeScript code with error handling
 * - Generate test cases
 * - Package skills for validation
 *
 * MVP: Template-based synthesis
 * Future: LLM-powered synthesis via Kilocode API
 */

import type {
	SkillMetadata,
	SkillTemplate,
	SkillSynthesisRequest,
	SkillScope,
	SkillRuntime,
	SkillType,
	SkillTemplateType,
	LearningSignal,
} from "@roo-code/types"

/** Configuration for SkillSynthesizer */
export interface SkillSynthesizerConfig {
	/** Default skill scope */
	defaultScope?: SkillScope

	/** Default runtime */
	defaultRuntime?: SkillRuntime

	/** Custom templates */
	customTemplates?: SkillTemplate[]

	/** Author name for generated skills */
	author?: string
}

/** Built-in templates for skill generation */
const BUILTIN_TEMPLATES: SkillTemplate[] = [
	{
		id: "file_processor",
		name: "File Processor",
		templateType: "file_processor",
		runtime: "typescript",
		description: "Process files with custom logic",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface Args {
  filePath: string;
  {{#each parameters}}
  {{name}}: {{type}};
  {{/each}}
}

export interface Result {
  success: boolean;
  message: string;
  data?: unknown;
}

/**
 * Main processing function
 */
export default async function process(args: Args): Promise<Result> {
  const { filePath{{#each parameters}}, {{name}}{{/each}} } = args;
  
  try {
    // Read the file
    console.log(\`Processing file: \${filePath}\`);
    
    {{processingLogic}}
    
    return {
      success: true,
      message: \`Successfully processed \${filePath}\`,
      data: result,
    };
  } catch (error) {
    return {
      success: false,
      message: \`Failed to process file: \${error instanceof Error ? error.message : String(error)}\`,
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
			{
				name: "processingLogic",
				description: "Custom processing logic",
				defaultValue: "const result = await processFile(filePath);",
				required: false,
			},
		],
		defaultPermissions: ["read_file"],
	},
	{
		id: "data_transformer",
		name: "Data Transformer",
		templateType: "data_transformer",
		runtime: "typescript",
		description: "Transform data between formats",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface InputData {
  {{inputType}}
}

export interface OutputData {
  {{outputType}}
}

export interface Args {
  data: InputData;
  options?: Record<string, unknown>;
}

export interface Result {
  success: boolean;
  output?: OutputData;
  error?: string;
}

/**
 * Transform data from input format to output format
 */
export default function transform(args: Args): Result {
  const { data, options = {} } = args;
  
  try {
    {{transformLogic}}
    
    return {
      success: true,
      output: transformed,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
			{
				name: "inputType",
				description: "Input data type definition",
				defaultValue: "input: unknown;",
				required: false,
			},
			{
				name: "outputType",
				description: "Output data type definition",
				defaultValue: "output: unknown;",
				required: false,
			},
			{
				name: "transformLogic",
				description: "Transformation logic",
				defaultValue: "const transformed = data as unknown as OutputData;",
				required: false,
			},
		],
		defaultPermissions: [],
	},
	{
		id: "api_client",
		name: "API Client",
		templateType: "api_client",
		runtime: "typescript",
		description: "Make API calls to external services",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface Args {
  endpoint: string;
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  body?: unknown;
  headers?: Record<string, string>;
  timeout?: number;
}

export interface Result {
  success: boolean;
  status?: number;
  data?: unknown;
  error?: string;
}

/**
 * Make an API request
 */
export default async function request(args: Args): Promise<Result> {
  const {
    endpoint,
    method = 'GET',
    body,
    headers = {},
    timeout = 10000,
  } = args;
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    const response = await fetch(endpoint, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      body: body ? JSON.stringify(body) : undefined,
      signal: controller.signal,
    });
    
    clearTimeout(timeoutId);
    
    const data = await response.json().catch(() => null);
    
    return {
      success: response.ok,
      status: response.status,
      data,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
		],
		defaultPermissions: ["network"],
	},
	{
		id: "command_runner",
		name: "Command Runner",
		templateType: "command_runner",
		runtime: "typescript",
		description: "Execute shell commands safely",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface Args {
  command: string;
  args?: string[];
  cwd?: string;
  timeout?: number;
}

export interface Result {
  success: boolean;
  exitCode?: number;
  stdout?: string;
  stderr?: string;
  error?: string;
}

/**
 * Execute a command
 * Note: This is a placeholder - actual execution requires system integration
 */
export default async function execute(args: Args): Promise<Result> {
  const {
    command,
    args: cmdArgs = [],
    cwd,
    timeout = 30000,
  } = args;
  
  try {
    // Placeholder for actual command execution
    // Real implementation would use child_process
    console.log(\`Would execute: \${command} \${cmdArgs.join(' ')}\`);
    console.log(\`Working directory: \${cwd ?? 'current'}\`);
    console.log(\`Timeout: \${timeout}ms\`);
    
    return {
      success: true,
      exitCode: 0,
      stdout: \`Simulated execution of: \${command}\`,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
		],
		defaultPermissions: ["execute_command"],
	},
	{
		id: "custom",
		name: "Custom Skill",
		templateType: "custom",
		runtime: "typescript",
		description: "Create a custom skill from scratch",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface Args {
  {{argsType}}
}

export interface Result {
  success: boolean;
  data?: unknown;
  error?: string;
}

/**
 * {{description}}
 */
export default async function main(args: Args): Promise<Result> {
  try {
    {{customCode}}
    
    return {
      success: true,
      data: result,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
			{
				name: "argsType",
				description: "Arguments type definition",
				defaultValue: "input?: unknown;",
				required: false,
			},
			{
				name: "customCode",
				description: "Custom implementation code",
				defaultValue: "const result = { message: 'Skill executed' };",
				required: false,
			},
		],
		defaultPermissions: [],
	},
]

/** Result of skill synthesis */
export interface SynthesisResult {
	success: boolean
	skill?: SkillMetadata
	code?: string
	testCode?: string
	error?: string
}

/**
 * SkillSynthesizer generates skills from templates or learning signals
 */
export class SkillSynthesizer {
	private config: Required<SkillSynthesizerConfig>
	private templates: Map<string, SkillTemplate>

	constructor(config: SkillSynthesizerConfig = {}) {
		this.config = {
			defaultScope: config.defaultScope ?? "project",
			defaultRuntime: config.defaultRuntime ?? "typescript",
			customTemplates: config.customTemplates ?? [],
			author: config.author ?? "Darwin Evolution System",
		}

		// Initialize templates
		this.templates = new Map()
		for (const template of BUILTIN_TEMPLATES) {
			this.templates.set(template.id, template)
		}
		for (const template of this.config.customTemplates) {
			this.templates.set(template.id, template)
		}
	}

	/**
	 * Synthesize a skill from a request
	 */
	synthesize(request: SkillSynthesisRequest): SynthesisResult {
		try {
			// Determine which template to use
			const templateId = request.templateId ?? "custom"
			const template = this.templates.get(templateId)

			if (!template && !request.customCode) {
				return {
					success: false,
					error: `Template not found: ${templateId}`,
				}
			}

			// Generate the code
			let code: string
			if (request.customCode) {
				code = this.wrapCustomCode(request.name, request.description, request.customCode)
			} else {
				code = this.generateFromTemplate(template!, request)
			}

			// Generate skill metadata
			const skill = this.generateMetadata(request, template)

			// Generate test code
			const testCode = this.generateTestCode(skill, template)

			return {
				success: true,
				skill,
				code,
				testCode,
			}
		} catch (error) {
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			}
		}
	}

	/**
	 * Synthesize a skill from a learning signal (doom loop resolution)
	 */
	synthesizeFromSignal(signal: LearningSignal): SynthesisResult {
		// Extract information from the signal
		const context = signal.context ?? {}
		const toolName = context.toolName as string | undefined
		const errorPattern = context.errorPattern as string | undefined
		const suggestedFix = signal.suggestedAction

		// Determine appropriate template based on signal type
		let templateId: string
		let customLogic = ""

		switch (signal.type) {
			case "doom_loop": {
				// Create a skill to handle the repetitive failure
				templateId = "custom"
				customLogic = this.generateDoomLoopHandler(toolName ?? "unknown", errorPattern, suggestedFix)
				break
			}

			case "capability_gap": {
				// Suggest a template based on the capability needed
				const capability = context.capability as string | undefined
				templateId = this.suggestTemplateForCapability(capability ?? "")
				break
			}

			case "inefficiency": {
				// Create an optimization skill
				templateId = "custom"
				customLogic = this.generateOptimizationSkill(context.area as string | undefined, suggestedFix)
				break
			}

			default:
				templateId = "custom"
		}

		const request: SkillSynthesisRequest = {
			name: this.generateSkillName(signal),
			description: signal.description,
			templateId,
			customCode: customLogic || undefined,
			runtime: this.config.defaultRuntime,
			scope: this.config.defaultScope,
			tags: [signal.type, toolName ?? "general"].filter(Boolean),
			sourceSignalId: signal.id,
		}

		return this.synthesize(request)
	}

	/**
	 * Get available templates
	 */
	getTemplates(): SkillTemplate[] {
		return Array.from(this.templates.values())
	}

	/**
	 * Get a specific template
	 */
	getTemplate(id: string): SkillTemplate | undefined {
		return this.templates.get(id)
	}

	/**
	 * Add a custom template
	 */
	addTemplate(template: SkillTemplate): void {
		this.templates.set(template.id, template)
	}

	/**
	 * Remove a template
	 */
	removeTemplate(id: string): boolean {
		// Don't allow removing builtin templates
		if (BUILTIN_TEMPLATES.some((t) => t.id === id)) {
			return false
		}
		return this.templates.delete(id)
	}

	// ==========================================================================
	// Private Methods
	// ==========================================================================

	private generateFromTemplate(template: SkillTemplate, request: SkillSynthesisRequest): string {
		let code = template.codeTemplate

		// Replace standard placeholders
		code = code.replace(/\{\{name\}\}/g, request.name)
		code = code.replace(/\{\{description\}\}/g, request.description)

		// Replace custom placeholders
		if (request.placeholderValues) {
			for (const [key, value] of Object.entries(request.placeholderValues)) {
				const regex = new RegExp(`\\{\\{${key}\\}\\}`, "g")
				code = code.replace(regex, value)
			}
		}

		// Replace remaining placeholders with defaults
		for (const placeholder of template.placeholders) {
			const regex = new RegExp(`\\{\\{${placeholder.name}\\}\\}`, "g")
			if (regex.test(code)) {
				code = code.replace(regex, placeholder.defaultValue ?? "")
			}
		}

		// Clean up Handlebars-like syntax
		code = code.replace(/\{\{#each\s+\w+\}\}[\s\S]*?\{\{\/each\}\}/g, "")

		return code
	}

	private wrapCustomCode(name: string, description: string, customCode: string): string {
		return `/**
 * ${name} - ${description}
 * Generated by Darwin Evolution System
 */

export interface Args {
  [key: string]: unknown;
}

export interface Result {
  success: boolean;
  data?: unknown;
  error?: string;
}

/**
 * ${description}
 */
export default async function main(args: Args): Promise<Result> {
  try {
${customCode
	.split("\n")
	.map((line) => "    " + line)
	.join("\n")}
    
    return {
      success: true,
      data: result,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`
	}

	private generateMetadata(request: SkillSynthesisRequest, template?: SkillTemplate): SkillMetadata {
		const now = Date.now()
		const id = this.generateSkillId(request.name)

		return {
			id,
			name: request.name,
			description: request.description,
			type: "workflow" as SkillType,
			runtime: request.runtime ?? this.config.defaultRuntime,
			scope: request.scope ?? this.config.defaultScope,
			implementationPath: `${id}.ts`,
			parameters: {},
			tags: request.tags ?? [],
			usageCount: 0,
			successCount: 0,
			failureCount: 0,
			active: true,
			version: "1.0.0",
			createdAt: now,
			updatedAt: now,
			sourceProposalId: undefined,
			author: this.config.author,
			permissions: template?.defaultPermissions ?? [],
		}
	}

	private generateTestCode(skill: SkillMetadata, template?: SkillTemplate): string {
		return `/**
 * Tests for ${skill.name}
 * Generated by Darwin Evolution System
 */

import { describe, it, expect } from 'vitest';
import main from './${skill.id}';

describe('${skill.name}', () => {
  it('should execute successfully with valid input', async () => {
    const result = await main({});
    
    expect(result).toBeDefined();
    expect(result.success).toBeDefined();
  });

  it('should handle errors gracefully', async () => {
    // Test with invalid input
    const result = await main({ invalidInput: true });
    
    expect(result).toBeDefined();
    // The skill should not throw, but return an error result
    expect(typeof result.success === 'boolean').toBe(true);
  });

  it('should complete within timeout', async () => {
    const startTime = Date.now();
    await main({});
    const duration = Date.now() - startTime;
    
    // Should complete within 5 seconds
    expect(duration).toBeLessThan(5000);
  });
});
`
	}

	private generateSkillId(name: string): string {
		const cleanName = name
			.toLowerCase()
			.replace(/[^a-z0-9]+/g, "_")
			.replace(/^_+|_+$/g, "")

		return `skill_${cleanName}_${Date.now().toString(36)}`
	}

	private generateSkillName(signal: LearningSignal): string {
		const context = signal.context ?? {}
		const toolName = context.toolName as string | undefined
		const type = signal.type.replace(/_/g, " ")

		if (toolName) {
			return `Handle ${toolName} ${type}`
		}

		return `${type.charAt(0).toUpperCase() + type.slice(1)} Handler`
	}

	private generateDoomLoopHandler(toolName: string, errorPattern?: string, suggestedFix?: string): string {
		return `// Doom loop handler for ${toolName}
const maxRetries = 3;
let retries = 0;

while (retries < maxRetries) {
  console.log(\`Attempt \${retries + 1} of \${maxRetries}\`);
  
  // ${suggestedFix ?? "Apply alternative approach"}
  try {
    // Attempt the operation with modified approach
    const result = await attemptOperation(args);
    if (result.success) {
      break;
    }
  } catch (error) {
    console.log(\`Attempt failed: \${error}\`);
  }
  
  retries++;
}

const result = { handled: true, retries };`
	}

	private generateOptimizationSkill(area?: string, suggestion?: string): string {
		return `// Optimization for ${area ?? "workflow"}
console.log('Applying optimization...');

// ${suggestion ?? "Apply optimized approach"}
const optimizedResult = await optimizeProcess(args);

const result = optimizedResult;`
	}

	private suggestTemplateForCapability(capability: string): string {
		const lowerCapability = capability.toLowerCase()

		if (lowerCapability.includes("file") || lowerCapability.includes("read") || lowerCapability.includes("write")) {
			return "file_processor"
		}

		if (lowerCapability.includes("api") || lowerCapability.includes("http") || lowerCapability.includes("fetch")) {
			return "api_client"
		}

		if (
			lowerCapability.includes("transform") ||
			lowerCapability.includes("convert") ||
			lowerCapability.includes("parse")
		) {
			return "data_transformer"
		}

		if (
			lowerCapability.includes("command") ||
			lowerCapability.includes("execute") ||
			lowerCapability.includes("shell")
		) {
			return "command_runner"
		}

		return "custom"
	}
}
