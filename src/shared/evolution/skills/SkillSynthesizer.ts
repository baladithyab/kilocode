/**
 * SkillSynthesizer - Template-based and hybrid skill generation for Darwin
 *
 * Responsibilities:
 * - Generate skills from templates
 * - Generate skills from doom_loop learning signals
 * - Create TypeScript code with error handling
 * - Generate test cases
 * - Package skills for validation
 * - Support hybrid synthesis with LLM (Phase 4C)
 *
 * MVR: Template-based synthesis with optional LLM enhancement
 */

import type {
	SkillMetadata,
	SkillTemplate,
	SkillSynthesisRequest,
	SkillScope,
	SkillRuntime,
	SkillType,
	SkillTemplateType,
	LearningSignal,
	SynthesisStrategy,
	SynthesisContext,
	LLMSynthesisConfig,
} from "@roo-code/types"

import { DEFAULT_LLM_SYNTHESIS_CONFIG } from "@roo-code/types"

/** Import LLMSkillSynthesizer for hybrid mode */
import { LLMSkillSynthesizer, type LLMApiProvider } from "./LLMSkillSynthesizer"

/** Configuration for SkillSynthesizer */
export interface SkillSynthesizerConfig {
	/** Default skill scope */
	defaultScope?: SkillScope

	/** Default runtime */
	defaultRuntime?: SkillRuntime

	/** Custom templates */
	customTemplates?: SkillTemplate[]

	/** Author name for generated skills */
	author?: string

	/** Synthesis strategy: template, llm, or hybrid (Phase 4C) */
	synthesisStrategy?: SynthesisStrategy

	/** LLM synthesis configuration */
	llmConfig?: Partial<LLMSynthesisConfig>

	/** API provider for LLM calls (required for llm or hybrid strategy) */
	apiProvider?: LLMApiProvider
}

/** Built-in templates for skill generation */
const BUILTIN_TEMPLATES: SkillTemplate[] = [
	{
		id: "file_processor",
		name: "File Processor",
		templateType: "file_processor",
		runtime: "typescript",
		description: "Process files with custom logic",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface Args {
  filePath: string;
  {{#each parameters}}
  {{name}}: {{type}};
  {{/each}}
}

export interface Result {
  success: boolean;
  message: string;
  data?: unknown;
}

/**
 * Main processing function
 */
export default async function process(args: Args): Promise<Result> {
  const { filePath{{#each parameters}}, {{name}}{{/each}} } = args;
  
  try {
    // Read the file
    console.log(\`Processing file: \${filePath}\`);
    
    {{processingLogic}}
    
    return {
      success: true,
      message: \`Successfully processed \${filePath}\`,
      data: result,
    };
  } catch (error) {
    return {
      success: false,
      message: \`Failed to process file: \${error instanceof Error ? error.message : String(error)}\`,
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
			{
				name: "processingLogic",
				description: "Custom processing logic",
				defaultValue: "const result = await processFile(filePath);",
				required: false,
			},
		],
		defaultPermissions: ["read_file"],
	},
	{
		id: "data_transformer",
		name: "Data Transformer",
		templateType: "data_transformer",
		runtime: "typescript",
		description: "Transform data between formats",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface InputData {
  {{inputType}}
}

export interface OutputData {
  {{outputType}}
}

export interface Args {
  data: InputData;
  options?: Record<string, unknown>;
}

export interface Result {
  success: boolean;
  output?: OutputData;
  error?: string;
}

/**
 * Transform data from input format to output format
 */
export default function transform(args: Args): Result {
  const { data, options = {} } = args;
  
  try {
    {{transformLogic}}
    
    return {
      success: true,
      output: transformed,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
			{
				name: "inputType",
				description: "Input data type definition",
				defaultValue: "input: unknown;",
				required: false,
			},
			{
				name: "outputType",
				description: "Output data type definition",
				defaultValue: "output: unknown;",
				required: false,
			},
			{
				name: "transformLogic",
				description: "Transformation logic",
				defaultValue: "const transformed = data as unknown as OutputData;",
				required: false,
			},
		],
		defaultPermissions: [],
	},
	{
		id: "api_client",
		name: "API Client",
		templateType: "api_client",
		runtime: "typescript",
		description: "Make API calls to external services",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface Args {
  endpoint: string;
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  body?: unknown;
  headers?: Record<string, string>;
  timeout?: number;
}

export interface Result {
  success: boolean;
  status?: number;
  data?: unknown;
  error?: string;
}

/**
 * Make an API request
 */
export default async function request(args: Args): Promise<Result> {
  const {
    endpoint,
    method = 'GET',
    body,
    headers = {},
    timeout = 10000,
  } = args;
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    const response = await fetch(endpoint, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      body: body ? JSON.stringify(body) : undefined,
      signal: controller.signal,
    });
    
    clearTimeout(timeoutId);
    
    const data = await response.json().catch(() => null);
    
    return {
      success: response.ok,
      status: response.status,
      data,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
		],
		defaultPermissions: ["network"],
	},
	{
		id: "command_runner",
		name: "Command Runner",
		templateType: "command_runner",
		runtime: "typescript",
		description: "Execute shell commands safely",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface Args {
  command: string;
  args?: string[];
  cwd?: string;
  timeout?: number;
}

export interface Result {
  success: boolean;
  exitCode?: number;
  stdout?: string;
  stderr?: string;
  error?: string;
}

/**
 * Execute a command
 * Note: This is a placeholder - actual execution requires system integration
 */
export default async function execute(args: Args): Promise<Result> {
  const {
    command,
    args: cmdArgs = [],
    cwd,
    timeout = 30000,
  } = args;
  
  try {
    // Placeholder for actual command execution
    // Real implementation would use child_process
    console.log(\`Would execute: \${command} \${cmdArgs.join(' ')}\`);
    console.log(\`Working directory: \${cwd ?? 'current'}\`);
    console.log(\`Timeout: \${timeout}ms\`);
    
    return {
      success: true,
      exitCode: 0,
      stdout: \`Simulated execution of: \${command}\`,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
		],
		defaultPermissions: ["execute_command"],
	},
	{
		id: "custom",
		name: "Custom Skill",
		templateType: "custom",
		runtime: "typescript",
		description: "Create a custom skill from scratch",
		codeTemplate: `/**
 * {{name}} - {{description}}
 * Generated by Darwin Evolution System
 */

export interface Args {
  {{argsType}}
}

export interface Result {
  success: boolean;
  data?: unknown;
  error?: string;
}

/**
 * {{description}}
 */
export default async function main(args: Args): Promise<Result> {
  try {
    {{customCode}}
    
    return {
      success: true,
      data: result,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`,
		placeholders: [
			{
				name: "name",
				description: "Skill name",
				required: true,
			},
			{
				name: "description",
				description: "Skill description",
				required: true,
			},
			{
				name: "argsType",
				description: "Arguments type definition",
				defaultValue: "input?: unknown;",
				required: false,
			},
			{
				name: "customCode",
				description: "Custom implementation code",
				defaultValue: "const result = { message: 'Skill executed' };",
				required: false,
			},
		],
		defaultPermissions: [],
	},
]

/** Result of skill synthesis */
export interface SynthesisResult {
	success: boolean
	skill?: SkillMetadata
	code?: string
	testCode?: string
	error?: string
	/** Whether LLM was used for synthesis (Phase 4C) */
	usedLLM?: boolean
	/** Explanation from LLM (if used) */
	explanation?: string
	/** Refinement attempts (if LLM used) */
	refinementAttempts?: number
}

/**
 * SkillSynthesizer generates skills from templates or learning signals
 * Supports hybrid mode with LLM synthesis (Phase 4C)
 */
export class SkillSynthesizer {
	private config: Required<
		Pick<SkillSynthesizerConfig, "defaultScope" | "defaultRuntime" | "customTemplates" | "author">
	> & {
		synthesisStrategy: SynthesisStrategy
		llmConfig: LLMSynthesisConfig
		apiProvider?: LLMApiProvider
	}
	private templates: Map<string, SkillTemplate>
	private llmSynthesizer?: LLMSkillSynthesizer

	constructor(config: SkillSynthesizerConfig = {}) {
		this.config = {
			defaultScope: config.defaultScope ?? "project",
			defaultRuntime: config.defaultRuntime ?? "typescript",
			customTemplates: config.customTemplates ?? [],
			author: config.author ?? "Darwin Evolution System",
			synthesisStrategy: config.synthesisStrategy ?? "template",
			llmConfig: { ...DEFAULT_LLM_SYNTHESIS_CONFIG, ...config.llmConfig },
			apiProvider: config.apiProvider,
		}

		// Initialize templates
		this.templates = new Map()
		for (const template of BUILTIN_TEMPLATES) {
			this.templates.set(template.id, template)
		}
		for (const template of this.config.customTemplates) {
			this.templates.set(template.id, template)
		}

		// Initialize LLM synthesizer if needed (hybrid or llm strategy)
		if (this.config.synthesisStrategy !== "template") {
			this.initializeLLMSynthesizer()
		}
	}

	/**
	 * Initialize the LLM synthesizer
	 */
	private initializeLLMSynthesizer(): void {
		this.llmSynthesizer = new LLMSkillSynthesizer({
			llmConfig: this.config.llmConfig,
			apiProvider: this.config.apiProvider,
			templateSynthesizer: this, // Pass self for fallback
			defaultScope: this.config.defaultScope,
			defaultRuntime: this.config.defaultRuntime,
			author: this.config.author,
		})
	}

	/**
	 * Set the API provider for LLM synthesis
	 */
	setApiProvider(provider: LLMApiProvider): void {
		this.config.apiProvider = provider

		// Initialize LLM synthesizer if not yet created and strategy needs it
		if (!this.llmSynthesizer && this.config.synthesisStrategy !== "template") {
			this.initializeLLMSynthesizer()
		}

		// Set provider on LLM synthesizer if it exists
		if (this.llmSynthesizer) {
			this.llmSynthesizer.setApiProvider(provider)
		}
	}

	/**
	 * Update synthesis strategy
	 */
	setSynthesisStrategy(strategy: SynthesisStrategy): void {
		this.config.synthesisStrategy = strategy
		if (strategy !== "template" && !this.llmSynthesizer) {
			this.initializeLLMSynthesizer()
		}
	}

	/**
	 * Check if LLM synthesis is available
	 */
	isLLMAvailable(): boolean {
		return this.llmSynthesizer?.isAvailable() ?? false
	}

	/**
	 * Synthesize a skill from a request
	 */
	synthesize(request: SkillSynthesisRequest): SynthesisResult {
		try {
			// Determine which template to use
			const templateId = request.templateId ?? "custom"
			const template = this.templates.get(templateId)

			if (!template && !request.customCode) {
				return {
					success: false,
					error: `Template not found: ${templateId}`,
				}
			}

			// Generate the code
			let code: string
			if (request.customCode) {
				code = this.wrapCustomCode(request.name, request.description, request.customCode)
			} else {
				code = this.generateFromTemplate(template!, request)
			}

			// Generate skill metadata
			const skill = this.generateMetadata(request, template)

			// Generate test code
			const testCode = this.generateTestCode(skill, template)

			return {
				success: true,
				skill,
				code,
				testCode,
				usedLLM: false,
			}
		} catch (error) {
			return {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			}
		}
	}

	/**
	 * Synthesize a skill from a learning signal (doom loop resolution)
	 * Uses the configured synthesis strategy
	 */
	synthesizeFromSignal(signal: LearningSignal): SynthesisResult {
		// For template-only mode, use the original template synthesis
		if (this.config.synthesisStrategy === "template") {
			return this.synthesizeFromSignalWithTemplate(signal)
		}

		// For LLM or hybrid mode, we need context for async synthesis
		// Return template result as sync fallback
		return this.synthesizeFromSignalWithTemplate(signal)
	}

	/**
	 * Synthesize a skill from a learning signal with context (async, for LLM)
	 * This is the main entry point for hybrid synthesis
	 */
	async synthesizeFromSignalAsync(signal: LearningSignal, context: SynthesisContext): Promise<SynthesisResult> {
		const strategy = this.config.synthesisStrategy

		// Template-only: use template synthesis
		if (strategy === "template") {
			return this.synthesizeFromSignalWithTemplate(signal)
		}

		// LLM-only: use LLM synthesis (no fallback on failure)
		if (strategy === "llm") {
			if (!this.llmSynthesizer || !this.llmSynthesizer.isAvailable()) {
				return {
					success: false,
					error: "LLM synthesis not available (no API provider configured)",
				}
			}

			const llmResult = await this.llmSynthesizer.synthesizeFromDoomLoop(signal, context)
			return this.convertLLMResult(llmResult, signal)
		}

		// Hybrid: try LLM first, fallback to template
		if (strategy === "hybrid") {
			// Check if LLM is available
			if (this.llmSynthesizer && this.llmSynthesizer.isAvailable()) {
				try {
					const llmResult = await this.llmSynthesizer.synthesizeFromDoomLoop(signal, context)

					if (llmResult.success && llmResult.code) {
						return this.convertLLMResult(llmResult, signal)
					}

					// LLM failed, fall through to template
					console.log("[SkillSynthesizer] LLM synthesis failed, falling back to template:", llmResult.error)
				} catch (error) {
					console.log("[SkillSynthesizer] LLM synthesis error, falling back to template:", error)
				}
			}

			// Fallback to template synthesis
			return this.synthesizeFromSignalWithTemplate(signal)
		}

		// Default fallback
		return this.synthesizeFromSignalWithTemplate(signal)
	}

	/**
	 * Synthesize with LLM directly (bypasses strategy, for testing)
	 */
	async synthesizeWithLLM(signal: LearningSignal, context: SynthesisContext): Promise<SynthesisResult> {
		if (!this.llmSynthesizer) {
			this.initializeLLMSynthesizer()
		}

		if (!this.llmSynthesizer || !this.llmSynthesizer.isAvailable()) {
			return {
				success: false,
				error: "LLM synthesis not available (no API provider configured)",
			}
		}

		const llmResult = await this.llmSynthesizer.synthesizeFromDoomLoop(signal, context)
		return this.convertLLMResult(llmResult, signal)
	}

	/**
	 * Convert LLM synthesis result to SynthesisResult
	 */
	private convertLLMResult(
		llmResult: import("@roo-code/types").LLMSynthesisResult,
		signal: LearningSignal,
	): SynthesisResult {
		if (!llmResult.success || !llmResult.code) {
			return {
				success: false,
				error: llmResult.error,
				usedLLM: true,
			}
		}

		const skill = this.generateMetadataFromLLM(llmResult, signal)
		const testCode = this.generateTestCode(skill)

		return {
			success: true,
			skill,
			code: llmResult.code,
			testCode,
			usedLLM: true,
			explanation: llmResult.explanation,
			refinementAttempts: llmResult.refinementAttempts,
		}
	}

	/**
	 * Generate metadata from LLM result
	 */
	private generateMetadataFromLLM(
		llmResult: import("@roo-code/types").LLMSynthesisResult,
		signal: LearningSignal,
	): SkillMetadata {
		const now = Date.now()
		const name = llmResult.suggestedName ?? this.generateSkillName(signal)
		const id = this.generateSkillId(name)

		return {
			id,
			name,
			description: llmResult.suggestedDescription ?? signal.description,
			type: "workflow" as SkillType,
			runtime: this.config.defaultRuntime,
			scope: this.config.defaultScope,
			implementationPath: `${id}.ts`,
			parameters: {},
			tags: [signal.type, "llm-synthesized"],
			usageCount: 0,
			successCount: 0,
			failureCount: 0,
			active: true,
			version: "1.0.0",
			createdAt: now,
			updatedAt: now,
			sourceProposalId: undefined,
			author: this.config.author,
			permissions: llmResult.requiredPermissions,
		}
	}

	/**
	 * Synthesize a skill from a learning signal using templates only
	 */
	private synthesizeFromSignalWithTemplate(signal: LearningSignal): SynthesisResult {
		// Extract information from the signal
		const context = signal.context ?? {}
		const toolName = context.toolName as string | undefined
		const errorPattern = context.errorPattern as string | undefined
		const suggestedFix = signal.suggestedAction

		// Determine appropriate template based on signal type
		let templateId: string
		let customLogic = ""

		switch (signal.type) {
			case "doom_loop": {
				// Create a skill to handle the repetitive failure
				templateId = "custom"
				customLogic = this.generateDoomLoopHandler(toolName ?? "unknown", errorPattern, suggestedFix)
				break
			}

			case "capability_gap": {
				// Suggest a template based on the capability needed
				const capability = context.capability as string | undefined
				templateId = this.suggestTemplateForCapability(capability ?? "")
				break
			}

			case "inefficiency": {
				// Create an optimization skill
				templateId = "custom"
				customLogic = this.generateOptimizationSkill(context.area as string | undefined, suggestedFix)
				break
			}

			default:
				templateId = "custom"
		}

		const request: SkillSynthesisRequest = {
			name: this.generateSkillName(signal),
			description: signal.description,
			templateId,
			customCode: customLogic || undefined,
			runtime: this.config.defaultRuntime,
			scope: this.config.defaultScope,
			tags: [signal.type, toolName ?? "general"].filter(Boolean),
			sourceSignalId: signal.id,
		}

		const result = this.synthesize(request)
		return {
			...result,
			usedLLM: false,
		}
	}

	/**
	 * Get available templates
	 */
	getTemplates(): SkillTemplate[] {
		return Array.from(this.templates.values())
	}

	/**
	 * Get a specific template
	 */
	getTemplate(id: string): SkillTemplate | undefined {
		return this.templates.get(id)
	}

	/**
	 * Add a custom template
	 */
	addTemplate(template: SkillTemplate): void {
		this.templates.set(template.id, template)
	}

	/**
	 * Remove a template
	 */
	removeTemplate(id: string): boolean {
		// Don't allow removing builtin templates
		if (BUILTIN_TEMPLATES.some((t) => t.id === id)) {
			return false
		}
		return this.templates.delete(id)
	}

	/**
	 * Get current synthesis strategy
	 */
	getSynthesisStrategy(): SynthesisStrategy {
		return this.config.synthesisStrategy
	}

	/**
	 * Get LLM synthesizer instance (for testing/metrics)
	 */
	getLLMSynthesizer(): LLMSkillSynthesizer | undefined {
		return this.llmSynthesizer
	}

	// ==========================================================================
	// Private Methods
	// ==========================================================================

	private generateFromTemplate(template: SkillTemplate, request: SkillSynthesisRequest): string {
		let code = template.codeTemplate

		// Replace standard placeholders
		code = code.replace(/\{\{name\}\}/g, request.name)
		code = code.replace(/\{\{description\}\}/g, request.description)

		// Replace custom placeholders
		if (request.placeholderValues) {
			for (const [key, value] of Object.entries(request.placeholderValues)) {
				const regex = new RegExp(`\\{\\{${key}\\}\\}`, "g")
				code = code.replace(regex, value)
			}
		}

		// Replace remaining placeholders with defaults
		for (const placeholder of template.placeholders) {
			const regex = new RegExp(`\\{\\{${placeholder.name}\\}\\}`, "g")
			if (regex.test(code)) {
				code = code.replace(regex, placeholder.defaultValue ?? "")
			}
		}

		// Clean up Handlebars-like syntax
		code = code.replace(/\{\{#each\s+\w+\}\}[\s\S]*?\{\{\/each\}\}/g, "")

		return code
	}

	private wrapCustomCode(name: string, description: string, customCode: string): string {
		return `/**
 * ${name} - ${description}
 * Generated by Darwin Evolution System
 */

export interface Args {
  [key: string]: unknown;
}

export interface Result {
  success: boolean;
  data?: unknown;
  error?: string;
}

/**
 * ${description}
 */
export default async function main(args: Args): Promise<Result> {
  try {
${customCode
	.split("\n")
	.map((line) => "    " + line)
	.join("\n")}
    
    return {
      success: true,
      data: result,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}
`
	}

	private generateMetadata(request: SkillSynthesisRequest, template?: SkillTemplate): SkillMetadata {
		const now = Date.now()
		const id = this.generateSkillId(request.name)

		return {
			id,
			name: request.name,
			description: request.description,
			type: "workflow" as SkillType,
			runtime: request.runtime ?? this.config.defaultRuntime,
			scope: request.scope ?? this.config.defaultScope,
			implementationPath: `${id}.ts`,
			parameters: {},
			tags: request.tags ?? [],
			usageCount: 0,
			successCount: 0,
			failureCount: 0,
			active: true,
			version: "1.0.0",
			createdAt: now,
			updatedAt: now,
			sourceProposalId: undefined,
			author: this.config.author,
			permissions: template?.defaultPermissions ?? [],
		}
	}

	private generateTestCode(skill: SkillMetadata, template?: SkillTemplate): string {
		return `/**
 * Tests for ${skill.name}
 * Generated by Darwin Evolution System
 */

import { describe, it, expect } from 'vitest';
import main from './${skill.id}';

describe('${skill.name}', () => {
  it('should execute successfully with valid input', async () => {
    const result = await main({});
    
    expect(result).toBeDefined();
    expect(result.success).toBeDefined();
  });

  it('should handle errors gracefully', async () => {
    // Test with invalid input
    const result = await main({ invalidInput: true });
    
    expect(result).toBeDefined();
    // The skill should not throw, but return an error result
    expect(typeof result.success === 'boolean').toBe(true);
  });

  it('should complete within timeout', async () => {
    const startTime = Date.now();
    await main({});
    const duration = Date.now() - startTime;
    
    // Should complete within 5 seconds
    expect(duration).toBeLessThan(5000);
  });
});
`
	}

	private generateSkillId(name: string): string {
		const cleanName = name
			.toLowerCase()
			.replace(/[^a-z0-9]+/g, "_")
			.replace(/^_+|_+$/g, "")

		// Include random suffix to ensure uniqueness even in rapid succession
		const randomSuffix = Math.random().toString(36).substring(2, 8)
		return `skill_${cleanName}_${Date.now().toString(36)}_${randomSuffix}`
	}

	private generateSkillName(signal: LearningSignal): string {
		const context = signal.context ?? {}
		const toolName = context.toolName as string | undefined
		const type = signal.type.replace(/_/g, " ")

		if (toolName) {
			return `Handle ${toolName} ${type}`
		}

		return `${type.charAt(0).toUpperCase() + type.slice(1)} Handler`
	}

	private generateDoomLoopHandler(toolName: string, errorPattern?: string, suggestedFix?: string): string {
		return `// Doom loop handler for ${toolName}
const maxRetries = 3;
let retries = 0;

while (retries < maxRetries) {
  console.log(\`Attempt \${retries + 1} of \${maxRetries}\`);
  
  // ${suggestedFix ?? "Apply alternative approach"}
  try {
    // Attempt the operation with modified approach
    const result = await attemptOperation(args);
    if (result.success) {
      break;
    }
  } catch (error) {
    console.log(\`Attempt failed: \${error}\`);
  }
  
  retries++;
}

const result = { handled: true, retries };`
	}

	private generateOptimizationSkill(area?: string, suggestion?: string): string {
		return `// Optimization for ${area ?? "workflow"}
console.log('Applying optimization...');

// ${suggestion ?? "Apply optimized approach"}
const optimizedResult = await optimizeProcess(args);

const result = optimizedResult;`
	}

	private suggestTemplateForCapability(capability: string): string {
		const lowerCapability = capability.toLowerCase()

		if (lowerCapability.includes("file") || lowerCapability.includes("read") || lowerCapability.includes("write")) {
			return "file_processor"
		}

		if (lowerCapability.includes("api") || lowerCapability.includes("http") || lowerCapability.includes("fetch")) {
			return "api_client"
		}

		if (
			lowerCapability.includes("transform") ||
			lowerCapability.includes("convert") ||
			lowerCapability.includes("parse")
		) {
			return "data_transformer"
		}

		if (
			lowerCapability.includes("command") ||
			lowerCapability.includes("execute") ||
			lowerCapability.includes("shell")
		) {
			return "command_runner"
		}

		return "custom"
	}
}
